---
layout:     post
title:      前端面试常见问题自我梳理
subtitle:    "\"写下我的回答，以便翻阅\""
date:       2019-07-09
author:     24253
header-img: img/HelloBlog.jpg
catalog: true
tags:
    - 2019
    - 大学学习
---

> “🙉🙉🙉 ”

## 前言

现在根据[腾讯前端暑期实习面经](https://www.nowcoder.com/discuss/197801)为目录进行回答，后续会拆分成HTML/CSS/JS/REACT/网络/...等知识领域。

## 正文

(√)自我介绍  
答：你好，我叫徐宇超，现在在浙江工商大学读大三/四，在校专业是信息安全。大三上选择了前端作为我的职业方向，主要通过自学来学习前端，学习了接近一年了，现在想找一份工作，（来XX面试是一种挑战）同时也检验一下我的知识水平和学习成果，如果能通过的话最好，但如果结果不太理想，那我觉得也能暴露出我的问题，

(√)怎么学前端的/说说你学前端的历程吧  
答：学习前端刚开始是在w3school这个网站上学html、css和js的基础知识。  
后来做了几个很小的网站，有点急，想提前进入框架学习，看了一遍vue官网的文档，发现大部分东西都看不懂。于是回去重学基础，找到《js高级程序设计》这本书囫囵吞枣地看了一遍。  
再后来发现视频学习比较有趣，去Youtube上看了很多教学视频，看他们如何从零开始建立一个网站，学到了很多新东西比如sass、响应式设计等。  
现在也有学习去看官方的文档来学习一个东西。

(√)CSS 常见两列布局、三列布局  
答：  
两列布局：一列定宽，一列自适应。
三列布局：两边定宽，中间自适应。详见下面的圣杯布局和双飞翼布局。

(√)CSS 水平垂直居中  
答：  
1. margin负值法(原始)  
父盒子设置:position:relative(absolute也行？)  
Div 设置: position:absolute; top: 50%;left: 50%; transform: translate(-50%，-50%);

2. table-cell（待完善）  
父盒子设置:display:table-cell; text-align:center;vertical-align:middle;  
Div 设置: display:inline-block;vertical-align:middle;

3. 利用flex(flexbox)  
将父元素设置为display:flex，并且设置align-items:center;justify-content:center;


()闭包，JS 没有闭包的话会怎么样  
答：一句话可以概括：闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。（待概括）  
没有闭包的话

(√)typeof 和 instanceof  
答：两者都是用来判断数据类型的。  
typeof判断基础类型没问题，引用类型如Array、Number、String时会输出object，无法准确判断。  
instanceof可以成功判断出各种引用类型，但是无法判断基础类型，可以判断基础类型的引用对象。  
Object.prototype.toString.call()可以成功判断出基础类型和引用类型。（number和Number？）

()js 的原型链，继承  
答：

(√)js 的 bind、apply、call 有什么区别  
答：  
通过apply和call改变函数的this指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply是数组，而call则是arg1,arg2...这种形式。  
通过bind改变this作用域会返回一个新的对象，这个对象不会马上执行。
详细看[这里](https://www.youtube.com/watch?v=c0mLRpw-9rI)

(√)var、let、const的区别  
答：  
var声明，其作用域是函数体的全部,会导致变量提升、重复声明等问题。  
let和const声明的变量有作用域，存在暂时性死区。  
let可以看成是var的更严格。  
const声明的变量值不能改变，一般用来声明常量。

(√)new 操作符原理（手动实现 new 给出思路）  
答:
1. 创建一个空对象obj，然后把这个空对象的（原型）__proto__设置为构造函数的prototype。
2. 构造函数被传入参数并调用，关键字this被设定指向该（实例）对象。
3. 返回这个对象。

()箭头函数，箭头函数 this 问题，箭头函数是否可以被 new  
答：
箭头函数是  
箭头函数中的this指向的是包裹箭头函数的环境的this，也就是说，在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用。  
箭头函数能被new吗?

()promise 知道吗，手写一个 promise 怎么写（说思路）  
答：

()promise.all 应用场景

(√)promise 和 async/await 的区别  
答：看[这里](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/33)。

(√)react 的生命周期（React16）  
答：  
每个组件都包含“生命周期方法”，你可以重写这些方法，以便于在运行过程中特定的阶段执行这些方法。你可以使用此生命周期图谱作为速查表。在下述列表中，常用的生命周期方法会被**加粗**。其余生命周期函数的使用则相对罕见。

挂载  
当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：  
**constructor()**  
static getDerivedStateFromProps()  
**render()**  
**componentDidMount()**

更新  
当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：  
static getDerivedStateFromProps()  
shouldComponentUpdate()  
**render()**  
getSnapshotBeforeUpdate()  
**componentDidUpdate()**

卸载  
当组件从 DOM 中移除时会调用如下方法：  
**componentWillUnmount()**

错误处理  
当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：  
static getDerivedStateFromError()  
componentDidCatch()

()react 性能优化

()react 的 diff 算法

()react 的 Fiber 架构

(√)状态码 304（强缓存和协商缓存）  
答：状态码304表示如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。即客户端和服务器端只需要传输很少的数据量来做文件的校验，如果文件没有修改过，则不需要返回全量的数据。

缓存分为两种：强缓存和协商缓存，根据响应的header内容来决定。  
具体看[这个](https://segmentfault.com/a/1190000008956069)

()加了面试官qq，视频手写原生 DOM 拖拽和大数相加（第二天）

()说说项目遇到的坑

(√)看你项目 ES6 用的比较多，说说 ES6 的一些新特性  
答: 箭头函数、const&let、块级作用域、promise、await&async、symbol。

()有没有考虑对图片处理的优化手段，说说常用的  
答:懒加载和预加载、压缩

()图片懒加载怎么做
答：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。（必要?）  

()考虑过缓存方面的优化吗，强缓存和协商缓存区别

(√)防抖和节流  
答：防抖和节流是两种预防高频率触发事件（比如scroll和resize）导致页面掉帧、影响用户体验的方法。  
防抖技术就是在一定时间内规定事件被触发的次数，用代码表示就是规定一个时间段，如果时间段内没有触发下一个scroll事件，那么才触发响应（callback）事件。  
节流是在防抖的基础上规定如果一个响应事件没有在一定时间段内触发过，那么就触发一次这个响应事件。
这样可以实现图片的懒加载等功能。

()dns 查询原理

(√)tcp 握手和挥手  
答：C发起请求连接S确认，也发起连接C确认我们再看看每次握手的作用：第一次握手：S只可以确认 自己可以接受C发送的报文段第二次握手：C可以确认 S收到了自己发送的报文段，并且可以确认 自己可以接受S发送的报文段第三次握手：S可以确认 C收到了自己发送的报文段

(√)tcp 和 udp区别，udp 使用场景  
答:  
（1）TCP是面向连接的可靠性传输，UDP则是无连接、不保证可靠交付。  
（2）TCP是面向字节流，UDP面向报文。  
（3）TCP只能是1对1的，UDP支持1对1,1对多。  
（4）TCP的首部较大为20字节，而UDP只有8字节。

udp一般用于即时通信（对速度要求高与数据准确性和丢包要求）、在线视频、网络电话。

(√)https 和 http区别
答：  
http是超文本传输协议，用于从服务器传输超文本到本地浏览器的传输协议。  
https是http的安全版，在http下多加了ssl层，对数据进行加密处理，使http不再明文传输。

(√)http2.0 相比 1.0 好在哪  
答： 
提升访问速度  
允许**多路复用**：多路复用允许同时通过单一的HTTP/2连接发送多重请求-响应信息。改善了：在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。  
规定了HTTP传输的所有内容都转为二进制进行传输 
对消息头部进行压缩传输  
服务器端能够更快地把资源推送到客户端

()抓包会吗，抓包原理，fiddler用过吗  
答：抓包上网络安全实验课的时候讲到过，老师让我们用wireshark来抓包分析http和tcp相关知识。

()跨域

(√)csrf、xss，如何预防  
答：  
xss(cross site script)也叫跨站脚本攻击，是通过漏洞往网站写入脚本来实现攻击。攻击方式有反射型(url或其他输入点注入)和存储型(存储到数据库后读取时注入)。理论上所有用户输入点都有可能存在xss漏洞。  
可以通过过滤用户输入、对cookie进行安全操作(设置成httponly，这样js就不能获取到该网站的cookie了)等操作进行防范。

csrf(cross site request forgery)也叫跨站请求伪造，就是让用户在不知情的情况，冒用其身份发起了一个请求。比如诱导用户点击一个攻击网址，攻击网址向被攻击网址发送请求，如果浏览器中存在此网站cookie，那么被攻击网址就会识别是用户操作，从而被攻击。  
可以通过验证 HTTP Referer 字段(它记录了该 HTTP 请求的来源地址)、设置验证码、在请求地址中添加token、在http头中添加token等方法进行防范。

()项目的 webpack 配置

()plugin 和 loader 的区别

()写过webpack的插件吗（没写过）

()webpack 单路口和多路口打包配置，为什么需要多路口

()babel 的编译原理，抽象语法树

()你有什么要问的吗？

()自我介绍，为什么会选择学前端呢？

()看你做了挺多项目，有没有在架构层面上考虑过对项目的优化

()MVC MVP MVVM 架构了解吗，他们的使用场景

()怎么理解前后端分离思想

()和后端一般是怎么沟通和联调的

()网络安全
答：

()后端技术栈了解哪些
答：node？

()有什么想问的吗？  
答：看[这里](https://juejin.im/post/5b7772a36fb9a019c372c14a)

()自我介绍，在校情况

(√)圣杯布局、双飞翼布局  
答：两个都是实现一个三列布局，中间自适应，两边固定宽。  
中间部分width：100% float：left 左/右部分width：200px；float：laft；margin-left/right：100%；（拉到上一行）  
接下来圣杯布局用父元素margin-left/right：200px；（或padding）左/右部分position: relative;left/right: -200px;实现  
双飞翼用中间加div innermargin-left: 200px;margin-right: 300px;将 inner 挤到中间实现  
中间自适应，两边固定宽用flex和grid更容易实现。

(√)CSS 媒体查询
答：  
写法:  
@media 设备类型 and （设备特征）{  
     div{width：200px；height：200px}  
}  
例:  
@media screen and (max-width:720px) and (min-width:320px)  
{ body{ background-color:red; } }

()CSS 动画、CSS 对网页性能优化

(√)浏览器渲染原理、回流与重绘
答：
1. 处理 HTML 标记并构建 DOM 树。
2. 处理 CSS 标记并构建 CSSOM 树。
3. 将 DOM 与 CSSOM 合并成一个渲染树。
4. 根据渲染树来布局，以计算每个节点的几何信息，将各个节点绘制到屏幕上。

回流：当渲染树的部分(或全部)因为元素的规模尺寸、布局，隐藏等改变而需要重新构建，这就称为回流(reflow)。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。

重绘：当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。

回流必将引起重绘，而重绘不一定会引起回流。

(√)JS 单线程、EventLoop、宏队列、微队列  
答：  
js是单线程执行的，因为如果是多线程，操作DOM就会有错误。  
js又需要处理并发任务，所以需要事件循环。  
先讨论浏览器事件环：
所有的宏任务放在一个宏任务队列（即任务队列），**处理完一个**宏任务(从sccript开始)，将微任务队列（包含当时所有的微任务）压入任务队列（宏任务队列）并执行，之后再取下一个任务队列（宏任务）中的宏任务。

讨论node事件环：

详细看[这里](https://juejin.im/post/5c910c9f6fb9a070e25a5f56)

()[几道题](https://juejin.im/post/5d2d146bf265da1b9163c5c9)

()Ajax 和 Fetch  
答：

()怎么同时让多个异步请求并行？

()跨域问题

()xss 和 csrf （聊到跨域基本都会聊跨域安全问题，所以这两个知识点可以一起准备）

()session 和 cookie

()服务器怎么知道 session 过期？

()怎么设置 cookie 过期时间

()sessionStorage 和 localStorage  
答：

(√)ES6 数组新增方法  
答：  
Array.map(根据callback函数，返回一个新数组)

Array.filter(根据callback，返回过滤后的数组)

Array.from(将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历的对象（包括 ES6 新增的数据结构 Set 和 Map）)

Array.of(用于将一组值，转换为数组，可用来新建数组)

Array.every(判断数组中所有元素是否符合条件，返回true/false)

Array.some(判断数组中是否有元素符合条件，返回true/false)

Array.find/findIndex(返回数组中符合条件的第一个元素，否则就返回undefined/这个方法是返回数组中符合条件的第一个元素的索引值，否则就返回-1)

(√)ES6 箭头函数和普通函数区别
答：  
1. this指向问题(箭头函数没有this，它的this指向定义时父作用域的this，也不能用call、bind、apply)
2. 不可以被当作构造函数
3. 不可以使用arguments对象，该对象在函数体内不存在，如果要用就用rest参数替代。
4. 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。

()promise、generator、async/await  

()react 父子组件传参  
答：[父子组件方法调用](https://juejin.im/post/59c150de51882529c44491e1)  
父组件向子组件传值：父组件把子组件处加上属性，属性值设置为要传递的值。  
子组件向父组件传值：先在父组件中写一个方法来接收子组件传过来的值，

()PureComponent 知道吗  

()React 性能优化  
答：[这里](https://juejin.im/post/5d045350f265da1b695d5bf2)

()Redux 原理，Redux 源码看过吗？ Redux 中间件呢？  

(√)JS 垃圾回收  
答：JS的垃圾回收机制的基本原理是：
> 找出那些不再继续使用的变量，然后释放其占用的内存，垃圾收集器会按照固定的时间间隔周期性的执行这一操作。
局部变量的生存周期是在函数声明和执行阶段，函数执行完毕后，局部变量就没有存在的必要了。全局变量会在浏览器关闭或进程关闭才能释放。  
但还有其他的较复杂场景(比如闭包、对象的相互引用)，垃圾回收器就没有那么容易的判断变量是否有用。  
目前在浏览器中有两种策略：
1. 标记清除：现代浏览器几乎都用这个垃圾回收算法。  
当变量进入执行环境时，就标记这个变量为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。  
垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。  
然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。  
最后，垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。  
会出现内存碎片问题，可以优化为标记-整理。
2. 引用计数：不太使用。  
此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。  
循环引用(互相引用)会引起内存泄漏问题。

详见：[这里](https://juejin.im/post/5c5ebc505188256219174f19)

()知道装饰器吗  

(√)数组方法 map、filter、reduce  
答：
- map：用来对数组中的每一个元素调用指定函数进行处理，返回一个新数组。
- filter：用来对数组进行过滤，过滤规则为制定函数，返回一个新数组，里面的元素均不满足过滤规则。
- reduce：用来对数组中的每个元素调用指定函数进行处理，返回最终的一个值，简单的实例就是累加。

新数据结构 Set、Map

babel 的编译原理

webpack 工作流程和原理，怎么写一个插件

从 url 到页面渲染过程

你刚说到 DNS 解析 能详细说说嘛？ DNS 递归和迭代的区别呢？

TCP ？ UDP ？ 区别是什么，你说 TCP 头部很大，具体有哪些报文信息呢？

页面渲染 重绘与重排 页面加载如何优化

http1.1 / http2.0 / https

聊聊数据结构的东西吧  算法怎么样？（一般..）

栈、队列、树、图一些基础

最短路径算法能简单聊聊实现吗 （迪杰斯特拉算法）

树的深度优先遍历、广度优先遍历实现和区别

一棵二叉树要用数组存储，这棵树要具备哪种条件？ （完全二叉树）

实现括号匹配用数据结构怎么做？说说思路 （栈）

快速排序原理

有什么想问我的？ 

说说项目中遇到的坑，怎么解决的

项目中有考虑到哪些优化的地方？

小程序的富文本为什么选用 wxParse，富文本原理

图片有哪些格式，知道 WebP 格式的图片吗，图片的一些优化手段

图片懒加载原理

跨域

前端常见攻击方式

(√)状态码  
答：  
2XX(Success 成功状态码)  
3XX(Redirection 重定向状态码)  
4XX(Client Error 客户端错误状态码)  
5XX(Server Error 服务器错误状态码)  
详细看[这里](https://juejin.im/post/5a276865f265da432c23b8d2)

强缓存和协商缓存

Node 的优势

Express 和 Koa 区别

react 路由原理

react hooks

redux 异步中间件实现原理

Vue MVVM原理

服务端渲染原理

nginx 的配置，反向代理、负载均衡原理

知道 PWA 吗

hybrid 技术

Flutter 了解吗

看过源码吗？

有什么想问的？

自我介绍，说说项目踩坑

使用框架踩到坑时，有没有去看过源码？

在做项目时，有没有从架构层面考虑过？

我现在有个需求，需要实现一个 web 端的微信，你想想该怎么实现

怎么看待前后端分离思想，以及服务端渲染技术

写过脚手架吗？

了解过设计模式吗？

()后端的技术栈有了解吗？  
答：node？

(√)平时是怎么学习的，学习习惯，为什么学前端？  
答：  
看youtube教学视频，看完看中文的文档，不行再看英文文档。  
学习习惯现在在用番茄学习法......  
因为前端比安全、后端更有趣，做的大部分都是看得见摸得着的东西因此正反馈更快(多)，更贴近用户，更看好其前景。

你有什么想问的？

()家庭情况
答：绍兴普通家庭，想要

平时是怎么学习的

说一个你做的最好的项目~

怎么看待现在的互联网趋势 （我说5G可能是第四次工业革命的导火索...）

如果要来深圳的话，方便吗

你有什么想问的吗？

---


## 后记


—— 24253 记于 2019-7-9


