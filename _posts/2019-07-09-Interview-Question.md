---
layout: post
title: 前端面试常见问题自我梳理
subtitle: '"写下我的回答，以便翻阅"'
date: 2019-07-09
author: 24253
header-img: img/Work.jpg
catalog: true
tags:
  - 2019
  - 大学学习
---

> “🙉🙉🙉 ”

## 新：

根据[2020 秋招牛客网阿里前端面经](https://www.nowcoder.com/discuss/tag/134?order=3&type=2&expTag=3&query=)整理

## HTML：

#### 重绘重排的原理，如果 DOM 下 100 个节点更新那会重排 100 次吗？

答：  
重绘  
由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如 outline, visibility, color、background-color 等，重绘的代价是高昂的，因为浏览器必须验证 DOM 树上其他节点元素的可见性。

回流  
回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及 DOM 中紧随其后的节点、祖先节点元素的随后的回流。

不会回流一百次  
现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即 16.6ms）才会清空队列(队列化修改并批量执行来优化重排过程)，但是有些属性会强制浏览器进行回流操作，比如 offsetTop/Left/Width/Height、scrollTop/Left/Width/Height、clientTop/Left/Width/Height。

---

---

## CSS：

#### 垂直水平居中：

1. margin 负值法(原始)  
   父盒子设置:position:relative(absolute 也行？)  
   Div 设置: position:absolute; top: 50%;left: 50%; transform: translate(-50%，-50%);

2. table-cell（待完善）  
   父盒子设置:display:table-cell; text-align:center;vertical-align:middle;  
   Div 设置: display:inline-block;vertical-align:middle;

3. 利用 flex/grid 布局
   将父元素设置为 display:flex/grid，并且设置 align-items:center;justify-content:center;

#### 怎么实现鼠标移动上去两秒后展开，移开两秒后慢慢回收的动画效果:

1. hover 和 animation delay？

2. onmouseover 和 onmouseout？

---

#### css3 的 position

---

## JS：

#### 基本数据类型

---

####判断类型方法

---

#### var、let、const 的区别

var 声明，其作用域是函数体的全部,会导致变量提升、重复声明等问题。  
let 和 const 声明的变量有作用域，存在暂时性死区。  
let 可以看成是 var 的更严格。  
const 声明的变量值不能改变，一般用来声明常量。
const 声明必须直接赋值。

---

#### const 声明的对象的属性值可以修改吗？：

---

#### call/apply/bind:

##### js 的 bind、apply、call 有什么区别

通过 apply 和 call 改变函数的 this 指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply 是数组，而 call 则是 arg1,arg2...这种形式。  
通过 bind 改变 this 作用域会返回一个新的对象，这个对象不会马上执行。
详细看[这里](https://www.youtube.com/watch?v=c0mLRpw-9rI)

---

### ES6

#### 对 es6 有什么了解？

---

#### 说说 ES6 的一些新特性

答: 箭头函数、const&let、块级作用域、promise、await&async、symbol。

---

#### symbol，怎么理解:

---

#### 深拷贝

---

#### 断点续传原理

---

#### 断点续传原理

---

#### 断点续传原理

---

#### ES6 数组新增方法

Array.map(根据 callback 函数，返回一个新数组)  
Array.filter(根据 callback，返回过滤后的数组)  
Array.from(将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历的对象（包括 ES6 新增的数据结构 Set 和 Map）)  
Array.of(用于将一组值，转换为数组，可用来新建数组)  
Array.every(判断数组中所有元素是否符合条件，返回 true/false)  
Array.some(判断数组中是否有元素符合条件，返回 true/false)  
Array.find/findIndex(返回数组中符合条件的第一个元素，否则就返回 undefined/这个方法是返回数组中符合条件的第一个元素的索引值，否则就返回-1)

---

#### ES6 箭头函数和普通函数区别：

箭头函数是 ES6 新出的一种函数形式。  
箭头函数中的 this 指向的是包裹箭头函数的环境的 this/指向定义时的环境，也就是说，在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用。  
箭头函数不能被 new 来实例化，换句话说不能被作为构造函数。  
箭头函数的 this 不可变，不能用 call、bind、apply 来改变。  
箭头函数没有 arguments 对象，如果要用就用 rest 参数替代。

---

#### 对 promise 的理解，对 async 和 await 的理解：

promise 和 async/await 的区别看[这里](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/33)。

##### promise 请求失败如何返回原来页面

##### aysnc、await 问怎么实现：

##### 问 generator 是啥···

##### es5 怎么搞 promise/手写一个 promise 怎么写：

#### 继承的方式:

---

### 闭包:

#### JS 没有闭包的话会怎么样:

一句话可以概括：闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。（待概括）  
没有闭包的话

---

### JS 垃圾回收

答：JS 的垃圾回收机制的基本原理是：

> 找出那些不再继续使用的变量，然后释放其占用的内存，垃圾收集器会按照固定的时间间隔周期性的执行这一操作。
> 局部变量的生存周期是在函数声明和执行阶段，函数执行完毕后，局部变量就没有存在的必要了。全局变量会在浏览器关闭或进程关闭才能释放。  
> 但还有其他的较复杂场景(比如闭包、对象的相互引用)，垃圾回收器就没有那么容易的判断变量是否有用。  
> 目前在浏览器中有两种策略：

1. 标记清除：现代浏览器几乎都用这个垃圾回收算法。  
   当变量进入执行环境时，就标记这个变量为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。  
   垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。  
   然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。  
   最后，垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。  
   会出现内存碎片问题，可以优化为标记-整理。
2. 引用计数：不太使用。  
   此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。  
   循环引用(互相引用)会引起内存泄漏问题。

## 详见：[这里](https://juejin.im/post/5c5ebc505188256219174f19)

---

## React/Vue：

#### react 的生命周期（React16）

每个组件都包含“生命周期方法”，你可以重写这些方法，以便于在运行过程中特定的阶段执行这些方法。你可以使用此生命周期图谱作为速查表。在下述列表中，常用的生命周期方法会被**加粗**。其余生命周期函数的使用则相对罕见。

挂载  
当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：  
**constructor()**  
static getDerivedStateFromProps()  
**render()**  
**componentDidMount()**

更新  
当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：  
static getDerivedStateFromProps()  
shouldComponentUpdate()  
**render()**  
getSnapshotBeforeUpdate()  
**componentDidUpdate()**

卸载  
当组件从 DOM 中移除时会调用如下方法：  
**componentWillUnmount()**

错误处理  
当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：  
static getDerivedStateFromError()  
componentDidCatch()

#### jquery 与 vue/react 的区别：

##### vue 和 react 的区别:

##### vuex 和 redux 的原理和区别：

#### 虚拟 dom：

---

#### diff 算法：

---

#### vue/react 最近的新技术：

---

## 前端工具：

#### 介绍一下 webpack 及使用过的插件：

---

#### wepack 中 plugin 与 loader 的区别：

---

#### 前端工程化:

---

#### web worker：

---

## 网络：

### https介绍一下

https就是安全版本的http，譬如一些支付等操作基本都是基于https的，因为http请求的安全系数太低了。

简单来看，https与http的区别就是： 在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析

一般来说，如果要将网站升级成https，需要后端支持（后端需要申请证书等），然后https的开销也比http要大（因为需要额外建立安全链接以及加密等），所以一般来说http2.0配合https的体验更佳（因为http2.0更快了）

#### https 使用的是 ssl 协议，如果服务端分发公钥，浏览器端使用私钥解密会话密钥会不会不安全？为什么？

---

### http2.0 有了解吗？

http2.0 不是 https，它相当于是 http 的下一代规范（譬如 https 的请求可以是 http2.0 规范的）

然后简述下 http2.0 与 http1.1 的显著不同点：

http1.1 中，每请求一个资源，都是需要开启一个 tcp/ip 连接的，所以对应的结果是，每一个资源对应一个 tcp/ip 请求，由于 tcp/ip 本身有并发数限制，所以当资源一多，速度就显著慢下来

http2.0 中，一个 tcp/ip 请求可以请求多个资源，也就是说，只要一次 tcp/ip 请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。

所以，如果 http2.0 全面应用，很多 http1.1 中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等）

http2.0 的一些特性：

多路复用（即一个 tcp/ip 连接可以请求多个资源）

首部压缩（http 头部压缩，减少体积）

二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）

服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）

请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）

---

#### TCP 三次握手，四次挥手？

---

#### http 报文的格式:

报文一般包括了：通用头部，请求/响应头部，请求/响应体

- 通用头部  
  这也是开发人员见过的最多的信息，包括如下：  
  Request Url: 请求的 web 服务器地址  
  Request Method: 请求方式  
  （Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）  
  Status Code: 请求的返回状态码，如 200 代表成功  
  Remote Address: 请求的远程服务器地址（会转为 IP）

- 请求/响应头部  
  常用的请求头部（https://dailc.github.io/2018/03/12/whenyouenteraurl.html）：  
  Content-Type：客户端发送出去实体内容的类型  
  常用的响应头部（https://dailc.github.io/2018/03/12/whenyouenteraurl.html）：  
  Access-Control-Allow-Headers: 服务器端允许的请求 Headers  
  Access-Control-Allow-Methods: 服务器端允许的请求方法  
  Access-Control-Allow-Origin: 服务器端允许的请求 Origin 头部（譬如为\*）  
  Content-Type：服务端返回的实体内容的类型

- 请求/响应实体  
  http 请求时，除了头部，还有消息实体，一般来说  
  请求实体中会将一些需要的参数都放入进入（用于 post 请求）。  
  譬如实体中可以放参数的序列化形式（a=1&b=2 这种），或者直接放表单对象（Form Data 对象，上传时可以夹杂参数以及文件），等等  
  而一般响应实体中，就是放服务端需要传给客户端的内容  
  一般现在的接口请求时，实体中就是对于的信息的 json 格式，而像页面请求这种，里面就是直接放了一个 html 字符串，然后浏览器自己解析并渲染。

---

#### 跨域的理解：

---

#### 输入 url 到显示出来的过程：

---

#### dns 解析过程：

---

#### tcp 为什么要连接，底层原理：

---

## 安全：

#### 项目安全怎么做的，你有想法吗：

答：  
xss:

csrf:

---

## 性能优化：

### 重绘与回流优化：

**CSS：**

1. 使用 transform 替代 top

2. 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局

3. 避免使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。

4. 尽可能在 DOM 树的最末端改变 class，回流是不可避免的，但可以减少其影响。尽可能在 DOM 树的最末端改变 class，可以限制了回流的范围，使其影响尽可能少的节点。

5. 避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。

```
<div>
  <a> <span></span> </a>
</div>
<style>
  span {
    color: red;
  }
  div > a > span {
    color: red;
  }
</style>
```

对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平。

5. 将动画效果应用到 position 属性为 absolute 或 fixed 的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame，详见探讨 requestAnimationFrame。

6. 避免使用 CSS 表达式，可能会引发回流。

7. 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如 will-change、video、iframe 等标签，浏览器会自动将该节点变为图层。

**JavaScript:**

1. 避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性。
2. 避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中。
3. 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
   对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

---

### CSS 对网页性能优化

---

### 有没有考虑对图片处理的优化手段，说说常用的

答:懒加载和预加载、对大的图片进行压缩。

#### 图片懒加载怎么做

答：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。（必要?）

---

### 考虑过缓存方面的优化吗，强缓存和协商缓存区别

---

### React 性能优化

答：[这里](https://juejin.im/post/5d045350f265da1b695d5bf2)

---

---

## 移动端：

---

## 可视化

#### canvas 了解吗？

## Node/后端：

#### 介绍一下 express：

---

#### 进程和线程:

---

## 算法

#### 一亿个订单找出金额最大的一万个数用什么方法时间复杂度和空间复杂度最低：

---

#### 有哪些排序方法:

---

#### npm 的含义：

Node Package Managermeng?

---

#### node 中版本号前的^什么意思：

## 项目：

#### 项目里面遇到的困难:

---

## 其他问题：

#### 为什么要用 html，为什么要用 css，为什么要用 js，不能用别的吗:

---

#### 自我介绍：

你好，我叫徐宇超，现在在浙江工商大学读大三/四，在校专业是信息安全。大三上选择了前端作为我的职业方向，主要通过自学来学习前端，学习了接近一年了，现在想找一份工作，（来 XX 面试是一种挑战）同时也检验一下我的知识水平和学习成果，如果能通过的话最好，但如果结果不太理想，那我觉得也能暴露出我的问题。

---

#### 怎么学前端的/说说你学前端的历程吧

学习前端刚开始是在 w3school 这个网站上学 html、css 和 js 的基础知识。  
后来做了几个很小的网站，有点急，想提前进入框架学习，看了一遍 vue 官网的文档，发现大部分东西都看不懂。于是回去重学基础，找到《js 高级程序设计》这本书囫囵吞枣地看了一遍。  
再后来发现视频学习比较有趣，去 Youtube 上看了很多教学视频，看他们如何从零开始建立一个网站，学到了很多新东西比如 sass、响应式设计等。  
现在也有学习去看官方的文档来学习一个东西。

#### 有什么要问的：

我们的技术栈是什么？/对我的评价/

---

#### 在学校最自豪的事

---

#### 个人优点

---

## 旧：

根据[腾讯前端暑期实习面经](https://www.nowcoder.com/discuss/197801)为目录进行回答，后续会拆分成 HTML/CSS/JS/REACT/网络/...等知识领域。

(√)CSS 常见两列布局、三列布局  
答：  
两列布局：一列定宽，一列自适应。
三列布局：两边定宽，中间自适应。详见下面的圣杯布局和双飞翼布局。

(√)CSS 水平垂直居中  
答：

1. margin 负值法(原始)  
   父盒子设置:position:relative(absolute 也行？)  
   Div 设置: position:absolute; top: 50%;left: 50%; transform: translate(-50%，-50%);

2. table-cell（待完善）  
   父盒子设置:display:table-cell; text-align:center;vertical-align:middle;  
   Div 设置: display:inline-block;vertical-align:middle;

3. 利用 flex(flexbox)  
   将父元素设置为 display:flex，并且设置 align-items:center;justify-content:center;

(√)typeof 和 instanceof  
答：两者都是用来判断数据类型的。  
typeof 判断基础类型没问题，引用类型如 Array、Number、String 时会输出 object，无法准确判断。  
instanceof 可以成功判断出各种引用类型，但是无法判断基础类型，可以判断基础类型的引用对象。  
Object.prototype.toString.call()可以成功判断出基础类型和引用类型。（number 和 Number？）

()js 的原型链，继承  
答：

(√)new 操作符原理（手动实现 new 给出思路）  
答:

1. 创建一个空对象 obj，然后把这个空对象的（原型）**proto**设置为构造函数的 prototype。
2. 构造函数被传入参数并调用，关键字 this 被设定指向该（实例）对象。
3. 返回这个对象。

(√)箭头函数，箭头函数 this 问题，箭头函数是否可以被 new  
答：  
箭头函数是 ES6 新出的一种函数形式。  
箭头函数中的 this 指向的是包裹箭头函数的环境的 this/指向定义时的环境，也就是说，在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用。  
箭头函数不能被 new 来实例化。  
箭头函数的 this 不可变。  
箭头函数没有 arguments 对象。

()promise.all 应用场景

()react 的 Fiber 架构

(√)状态码 304（强缓存和协商缓存）  
答：状态码 304 表示如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。即客户端和服务器端只需要传输很少的数据量来做文件的校验，如果文件没有修改过，则不需要返回全量的数据。

缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。  
具体看[这个](https://segmentfault.com/a/1190000008956069)

()加了面试官 qq，视频手写原生 DOM 拖拽和大数相加（第二天）

()说说项目遇到的坑

(√)防抖和节流  
答：防抖和节流是两种预防高频率触发事件（比如 scroll 和 resize）导致页面掉帧、影响用户体验的方法。  
防抖技术就是在一定时间内规定事件被触发的次数，用代码表示就是规定一个时间段，如果时间段内没有触发下一个 scroll 事件，那么才触发响应（callback）事件。  
节流是在防抖的基础上规定如果一个响应事件没有在一定时间段内触发过，那么就触发一次这个响应事件。
这样可以实现图片的懒加载等功能。

()dns 查询原理

(√)tcp 握手和挥手  
答：C 发起请求连接 S 确认，也发起连接 C 确认我们再看看每次握手的作用：第一次握手：S 只可以确认 自己可以接受 C 发送的报文段第二次握手：C 可以确认 S 收到了自己发送的报文段，并且可以确认 自己可以接受 S 发送的报文段第三次握手：S 可以确认 C 收到了自己发送的报文段

(√)tcp 和 udp 区别，udp 使用场景  
答:  
（1）TCP 是面向连接的可靠性传输，UDP 则是无连接、不保证可靠交付。  
（2）TCP 是面向字节流，UDP 面向报文。  
（3）TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多。  
（4）TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。

udp 一般用于即时通信（对速度要求高与数据准确性和丢包要求）、在线视频、网络电话。

(√)https 和 http 区别
答：  
http 是超文本传输协议，用于从服务器传输超文本到本地浏览器的传输协议。  
https 是 http 的安全版，在 http 下多加了 ssl 层，对数据进行加密处理，使 http 不再明文传输。

(√)http2.0 相比 1.0 好在哪  
答：
提升访问速度  
允许**多路复用**：多路复用允许同时通过单一的 HTTP/2 连接发送多重请求-响应信息。改善了：在 http1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。  
规定了 HTTP 传输的所有内容都转为二进制进行传输
对消息头部进行压缩传输  
服务器端能够更快地把资源推送到客户端

()抓包会吗，抓包原理，fiddler 用过吗  
答：抓包上网络安全实验课的时候讲到过，老师让我们用 wireshark 来抓包分析 http 和 tcp 相关知识。

()跨域

(√)csrf、xss，如何预防  
答：  
xss(cross site script)也叫跨站脚本攻击，是通过漏洞往网站写入脚本来实现攻击。攻击方式有反射型(url 或其他输入点注入)和存储型(存储到数据库后读取时注入)。理论上所有用户输入点都有可能存在 xss 漏洞。  
可以通过过滤用户输入、对 cookie 进行安全操作(设置成 httponly，这样 js 就不能获取到该网站的 cookie 了)等操作进行防范。

csrf(cross site request forgery)也叫跨站请求伪造，就是让用户在不知情的情况，冒用其身份发起了一个请求。比如诱导用户点击一个攻击网址，攻击网址向被攻击网址发送请求，如果浏览器中存在此网站 cookie，那么被攻击网址就会识别是用户操作，从而被攻击。  
可以通过验证 HTTP Referer 字段(它记录了该 HTTP 请求的来源地址)、设置验证码、在请求地址中添加 token、在 http 头中添加 token 等方法进行防范。

()项目的 webpack 配置

()plugin 和 loader 的区别

()写过 webpack 的插件吗（没写过）

()webpack 单路口和多路口打包配置，为什么需要多路口

()babel 的编译原理，抽象语法树

()你有什么要问的吗？

()自我介绍，为什么会选择学前端呢？

()MVC MVP MVVM 架构了解吗，他们的使用场景

()怎么理解前后端分离思想

()和后端一般是怎么沟通和联调的

()网络安全
答：

()后端技术栈了解哪些
答：node？

()有什么想问的吗？  
答：看[这里](https://juejin.im/post/5b7772a36fb9a019c372c14a)

()自我介绍，在校情况

(√)圣杯布局、双飞翼布局  
答：两个都是实现一个三列布局，中间自适应，两边固定宽。  
中间部分 width：100% float：left 左/右部分 width：200px；float：laft；margin-left/right：100%；（拉到上一行）  
接下来圣杯布局用父元素 margin-left/right：200px；（或 padding）左/右部分 position: relative;left/right: -200px;实现  
双飞翼用中间加 div innermargin-left: 200px;margin-right: 300px;将 inner 挤到中间实现  
中间自适应，两边固定宽用 flex 和 grid 更容易实现。

(√)CSS 媒体查询
答：  
写法:  
@media 设备类型 and （设备特征）{  
 div{width：200px；height：200px}  
}  
例:  
@media screen and (max-width:720px) and (min-width:320px)  
{ body{ background-color:red; } }

()CSS 动画

(√)浏览器渲染原理、回流与重绘
答：

1. 处理 HTML 标记并构建 DOM 树。
2. 处理 CSS 标记并构建 CSSOM 树。
3. 将 DOM 与 CSSOM 合并成一个渲染树。
4. 根据渲染树来布局，以计算每个节点的几何信息，将各个节点绘制到屏幕上。

回流：当渲染树的部分(或全部)因为元素的规模尺寸、布局，隐藏等改变而需要重新构建，这就称为回流(reflow)。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。

重绘：当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。则就叫称为重绘。

回流必将引起重绘，而重绘不一定会引起回流。

(√)JS 单线程、EventLoop、宏队列、微队列  
答：  
js 是单线程执行的，因为如果是多线程，操作 DOM 就会有错误。  
js 又需要处理并发任务，所以需要事件循环。  
先讨论浏览器事件环：
所有的宏任务放在一个宏任务队列（即任务队列），**处理完一个**宏任务(从 sccript 开始)，将微任务队列（包含当时所有的微任务）压入任务队列（宏任务队列）并执行，之后再取下一个任务队列（宏任务）中的宏任务。

讨论 node 事件环：

详细看[这里](https://juejin.im/post/5c910c9f6fb9a070e25a5f56)

()[几道题](https://juejin.im/post/5d2d146bf265da1b9163c5c9)

()Ajax 和 Fetch  
答：

()怎么同时让多个异步请求并行？

()跨域问题

()xss 和 csrf （聊到跨域基本都会聊跨域安全问题，所以这两个知识点可以一起准备）

()session 和 cookie

()服务器怎么知道 session 过期？

()怎么设置 cookie 过期时间

()sessionStorage 和 localStorage  
答：

()promise、generator、async/await

()react 父子组件传参  
答：[父子组件方法调用](https://juejin.im/post/59c150de51882529c44491e1)  
父组件向子组件传值：父组件把子组件处加上属性，属性值设置为要传递的值。  
子组件向父组件传值：先在父组件中写一个方法来接收子组件传过来的值，

()PureComponent 知道吗

()Redux 原理，Redux 源码看过吗？ Redux 中间件呢？

()知道装饰器吗

(√)数组方法 map、filter、reduce  
答：

- map：用来对数组中的每一个元素调用指定函数进行处理，返回一个新数组。
- filter：用来对数组进行过滤，过滤规则为制定函数，返回一个新数组，里面的元素均不满足过滤规则。
- reduce：用来对数组中的每个元素调用指定函数进行处理，返回最终的一个值，简单的实例就是累加。

新数据结构 Set、Map

babel 的编译原理

webpack 工作流程和原理，怎么写一个插件

从 url 到页面渲染过程

你刚说到 DNS 解析 能详细说说嘛？ DNS 递归和迭代的区别呢？

TCP ？ UDP ？ 区别是什么，你说 TCP 头部很大，具体有哪些报文信息呢？

页面渲染 重绘与重排 页面加载如何优化

http1.1 / http2.0 / https

聊聊数据结构的东西吧 算法怎么样？（一般..）

栈、队列、树、图一些基础

最短路径算法能简单聊聊实现吗 （迪杰斯特拉算法）

树的深度优先遍历、广度优先遍历实现和区别

一棵二叉树要用数组存储，这棵树要具备哪种条件？ （完全二叉树）

实现括号匹配用数据结构怎么做？说说思路 （栈）

快速排序原理

有什么想问我的？

说说项目中遇到的坑，怎么解决的

项目中有考虑到哪些优化的地方？

小程序的富文本为什么选用 wxParse，富文本原理

图片有哪些格式，知道 WebP 格式的图片吗，图片的一些优化手段

图片懒加载原理

跨域

前端常见攻击方式

(√)状态码  
答：  
2XX(Success 成功状态码)  
3XX(Redirection 重定向状态码)  
4XX(Client Error 客户端错误状态码)  
5XX(Server Error 服务器错误状态码)  
详细看[这里](https://juejin.im/post/5a276865f265da432c23b8d2)

强缓存和协商缓存

Node 的优势

Express 和 Koa 区别

react 路由原理

react hooks

redux 异步中间件实现原理

Vue MVVM 原理

服务端渲染原理

nginx 的配置，反向代理、负载均衡原理

知道 PWA 吗

hybrid 技术

Flutter 了解吗

看过源码吗？

有什么想问的？

自我介绍，说说项目踩坑

使用框架踩到坑时，有没有去看过源码？

在做项目时，有没有从架构层面考虑过？

我现在有个需求，需要实现一个 web 端的微信，你想想该怎么实现

怎么看待前后端分离思想，以及服务端渲染技术

写过脚手架吗？

了解过设计模式吗？

()后端的技术栈有了解吗？  
答：node？

(√)平时是怎么学习的，学习习惯，为什么学前端？  
答：  
看 youtube 教学视频，看完看中文的文档，不行再看英文文档。  
学习习惯现在在用番茄学习法......  
因为前端比安全、后端更有趣，做的大部分都是看得见摸得着的东西因此正反馈更快(多)，更贴近用户，更看好其前景。

你有什么想问的？

()家庭情况
答：绍兴普通家庭，想要

平时是怎么学习的

说一个你做的最好的项目~

怎么看待现在的互联网趋势 （我说 5G 可能是第四次工业革命的导火索...）

如果要来深圳的话，方便吗

你有什么想问的吗？

---

## 后记

—— 24253 记于 2019-7-9
